#!/usr/bin/env bash
set -e

# source in helper functions
source "$( dirname "${BASH_SOURCE[0]}" )/helpers/helpers.sh"

projectDir=$(pwd)
contractsPath="contracts"
contractsBasePath="${projectDir}/${contractsPath}"

# check if contractsBasePath ends with contracts
if [[ "$contractsBasePath" != *"contracts" ]]; then
    log "Error: contractsBasePath should end with contracts, got ${contractsBasePath}"
    exit 1
fi

# Function to get ABI path for a contract name
get_abi_path() {
    local name="$1"
    echo "${contractsBasePath}/out/$name.sol/$name.json"
}

# Function to process deployment output file and add contracts to deployed_contracts array
process_output_file() {
    log "Processing output file $2 - '$1'"
    local file_path="$1"
    local file_desc="$2"
    
    if [ ! -f "$file_path" ]; then
        log "Error: $file_desc output file $file_path not found"
        exit 1
    fi
    
    # Extract entries with properly formatted abi paths
    while read -r entry; do
        name=$(echo "$entry" | jq -r '.name')
        address=$(echo "$entry" | jq -r '.address')
        abi_path=$(get_abi_path "$name")

        # Check if ABI file exists
        if [ ! -f "$abi_path" ]; then
            log "Warning: ABI file $abi_path does not exist for contract $name. Run 'devkit avs build' first."
        fi

        # convert path back to relative to the project. take abi_path and remove $projectDir
        abi_path=$(echo "$abi_path" | sed "s|$projectDir/||")

        contract_json=$(jq -n \
            --arg name "$name" \
            --arg address "$address" \
            --arg abi "$abi_path" \
            '{ name: $name, address: $address, abi: $abi }')
        
        deployed_contracts=$(echo "$deployed_contracts" | jq ". + [$contract_json]")
    done < <(jq -c '.addresses | to_entries[] | {name: .key, address: .value}' "$file_path")
}

# Check if context parameter is provided
if [ -z "$1" ]; then
    log "Error: Missing context parameter"
    log "Usage: ./deployL2Contracts '{\"version\":\"0.0.1\",\"context\":{...}}'"
    exit 1
fi

# Parse the JSON context
CONTEXT="$1"

# Check for required tools
ensureJq
ensureYq
ensureMake
ensureForge

# Extract required values from context
ENVIRONMENT=$(echo "$CONTEXT" | jq -r '.context.name')
L2_RPC_URL=$(echo "$CONTEXT" | jq -r '.context.chains.l2.rpc_url')
PRIVATE_KEY_DEPLOYER=$(echo "$CONTEXT" | jq -r '.context.deployer_private_key')

# Add 0x prefix to private key if missing
if [[ "$PRIVATE_KEY_DEPLOYER" != 0x* ]]; then
    PRIVATE_KEY_DEPLOYER="0x$PRIVATE_KEY_DEPLOYER"
fi

# Function to validate required field
validate_required_field() {
    local value=$1
    local field_name=$2
    if [ "$value" == "null" ] || [ -z "$value" ]; then
        log "Error: Missing $field_name in context"
        exit 1
    fi
}

# Validate required fields exist in JSON
validate_required_field "$L2_RPC_URL" "chains.l2.rpc_url"
validate_required_field "$PRIVATE_KEY_DEPLOYER" "deployer_private_key"
validate_required_field "$ENVIRONMENT" "name (environment)"

log "Starting L2 contract deployment using context for environment: $ENVIRONMENT"

# Change to contracts directory
cd $contractsBasePath

# Check if there are any L2 contracts to deploy
L2_CONTRACTS_DIR="src/l2-contracts"
HAS_L2_CONTRACTS=false

if [ -d "$L2_CONTRACTS_DIR" ] && [ "$(find "$L2_CONTRACTS_DIR" -name "*.sol" | wc -l)" -gt 0 ]; then
    HAS_L2_CONTRACTS=true
fi

# Initialize an empty array for deployed contracts
deployed_contracts='[]'

# Deploy L2 contracts if any exist
if [ "$HAS_L2_CONTRACTS" == "true" ]; then
    log "Deploying L2 contracts..."
    
    # Ensure output directory exists
    mkdir -p script/$ENVIRONMENT/output
    
    # Deploy L2 contracts using forge script
    forge script script/DeployMyL2Contracts.s.sol \
        --rpc-url "${L2_RPC_URL}" \
        --private-key "${PRIVATE_KEY_DEPLOYER}" \
        --broadcast \
        --sig "run(string,string)" \
        "${ENVIRONMENT}" \
        "${CONTEXT}" >&2
    
    log "L2 contract deployment completed successfully."
    
    # Process deployment output
    OUTPUT_DIR="script/${ENVIRONMENT}/output"
    CUSTOM_CONTRACTS_L2_FILE="${OUTPUT_DIR}/deploy_custom_contracts_l2_output.json"
    if [ -f "$CUSTOM_CONTRACTS_L2_FILE" ]; then
        process_output_file "$CUSTOM_CONTRACTS_L2_FILE" "L2 Contracts"
    fi
else
    log "No L2 contracts found, skipping deployment."
fi

# Create the final JSON structure with deployed_contracts key
RESULT=$(jq -n --argjson contracts "$deployed_contracts" '{ deployed_l2_contracts: $contracts }')

# Print the combined JSON result - this is the ONLY stdout output
echo "$RESULT" | jq -c .
