#!/usr/bin/env bash
set -e

# source in helper functions
source "$( dirname "${BASH_SOURCE[0]}" )/helpers/helpers.sh"

projectDir=$(pwd)
devkitContractsPath=".devkit/compute-tee/contracts"
contractsBasePath="${projectDir}/${devkitContractsPath}"

# check if contractsBasePath ends with .devkit/compute-tee/contracts
if [[ "$contractsBasePath" != *".devkit/compute-tee/contracts" ]]; then
    log "Error: contractsBasePath should end with .devkit/compute-tee/contracts, got ${contractsBasePath}"
    exit 1
fi

# Function to get ABI path for a contract name
get_abi_path() {
    local name="$1"
    echo "${contractsBasePath}/out/$name.sol/$name.json"
}

# Function to process deployment output file and add contracts to deployed_contracts array
process_output_file() {
    log "Processing output file $2 - '$1'"
    local file_path="$1"
    local file_desc="$2"
    
    if [ ! -f "$file_path" ]; then
        log "Error: $file_desc output file $file_path not found"
        exit 1
    fi
    
    # Extract entries with properly formatted abi paths
    while read -r entry; do
        name=$(echo "$entry" | jq -r '.name')
        address=$(echo "$entry" | jq -r '.address')
        abi_path=$(get_abi_path "$name")

        # Check if ABI file exists
        if [ ! -f "$abi_path" ]; then
            log "Warning: ABI file $abi_path does not exist for contract $name. Run 'devkit avs build' first."
        fi

        # convert path back to relative to the project. take abi_path and remove $projectDir
        abi_path=$(echo "$abi_path" | sed "s|$projectDir/||")

        contract_json=$(jq -n \
            --arg name "$name" \
            --arg address "$address" \
            --arg abi "$abi_path" \
            '{ name: $name, address: $address, abi: $abi }')
        
        deployed_contracts=$(echo "$deployed_contracts" | jq ". + [$contract_json]")
    done < <(jq -c '.addresses | to_entries[] | {name: .key, address: .value}' "$file_path")
}

# Check if context parameter is provided
if [ -z "$1" ]; then
    log "Error: Missing context parameter"
    log "Usage: ./deployL1Contracts '{\"version\":\"0.0.1\",\"context\":{...}}'"
    exit 1
fi

# Parse the JSON context
CONTEXT="$1"

# Check for required tools
ensureJq
ensureYq
ensureMake
ensureForge

# Extract required values from context
ENVIRONMENT=$(echo "$CONTEXT" | jq -r '.context.name')
L1_RPC_URL=$(echo "$CONTEXT" | jq -r '.context.chains.l1.rpc_url')
PRIVATE_KEY_DEPLOYER=$(echo "$CONTEXT" | jq -r '.context.deployer_private_key')
ADDRESS_DEPLOYER="$(cast wallet address --private-key $PRIVATE_KEY_DEPLOYER)"
DELEGATION_MANAGER_ADDRESS=$(echo "$CONTEXT" | jq -r '.context.eigenlayer.l1.delegation_manager')
ALLOCATION_MANAGER_ADDRESS=$(echo "$CONTEXT" | jq -r '.context.eigenlayer.l1.allocation_manager')
PERMISSION_CONTROLLER_ADDRESS=$(echo "$CONTEXT" | jq -r '.context.eigenlayer.l1.permission_controller')
KEY_REGISTRAR_ADDRESS=$(echo "$CONTEXT" | jq -r '.context.eigenlayer.l1.key_registrar')
RELEASE_MANAGER_ADDRESS=$(echo "$CONTEXT" | jq -r '.context.eigenlayer.l1.release_manager')

# Add 0x prefix to private key if missing
if [[ "$PRIVATE_KEY_DEPLOYER" != 0x* ]]; then
    PRIVATE_KEY_DEPLOYER="0x$PRIVATE_KEY_DEPLOYER"
fi

# Function to validate required field
validate_required_field() {
    local value=$1
    local field_name=$2
    if [ "$value" == "null" ] || [ -z "$value" ]; then
        log "Error: Missing $field_name in context"
        exit 1
    fi
}

# Validate required fields exist in JSON
validate_required_field "$L1_RPC_URL" "L1_RPC_URL"
validate_required_field "$PRIVATE_KEY_DEPLOYER" "deployer_private_key"
validate_required_field "$ENVIRONMENT" "name (environment)"
validate_required_field "$ALLOCATION_MANAGER_ADDRESS" "eigenlayer.l1.allocation_manager"
validate_required_field "$KEY_REGISTRAR_ADDRESS" "eigenlayer.l1.key_registrar"
validate_required_field "$PERMISSION_CONTROLLER_ADDRESS" "eigenlayer.l1.permission_controller"
validate_required_field "$DELEGATION_MANAGER_ADDRESS" "eigenlayer.l1.delegation_manager"
validate_required_field "$RELEASE_MANAGER_ADDRESS" "eigenlayer.l1.release_manager"

# Check if the template-specific TEE environment YAML file exists
ENVIRONMENT_YAML_FILE=".compute-tee/context/${ENVIRONMENT}.yaml"
if [ ! -f "$ENVIRONMENT_YAML_FILE" ]; then
    log "Error: TEE environment file ${ENVIRONMENT_YAML_FILE} does not exist"
    exit 1
fi

# Extract TEE AVS Factory address from YAML (only required for non-devnet environments)
if [ "$ENVIRONMENT" != "devnet" ]; then
    TEE_AVS_FACTORY=$(yq -r '.contracts.tee_avs_factory' "$ENVIRONMENT_YAML_FILE")
    if [ "$TEE_AVS_FACTORY" == "null" ] || [ -z "$TEE_AVS_FACTORY" ]; then
        log "Error: Missing contracts.tee_avs_factory in ${ENVIRONMENT_YAML_FILE}"
        exit 1
    fi
fi

# Validate Ethereum addresses (basic check)
validate_eth_address() {
    local addr=$1
    local name=$2
    if [[ ! "$addr" =~ ^0x[a-fA-F0-9]{40}$ ]]; then
        log "Error: $name must be a valid Ethereum address (0x followed by 40 hex characters)"
        exit 1
    fi
}

validate_eth_address "$DELEGATION_MANAGER_ADDRESS" "DELEGATION_MANAGER_ADDRESS"
validate_eth_address "$ALLOCATION_MANAGER_ADDRESS" "ALLOCATION_MANAGER_ADDRESS"
validate_eth_address "$PERMISSION_CONTROLLER_ADDRESS" "PERMISSION_CONTROLLER_ADDRESS"
validate_eth_address "$KEY_REGISTRAR_ADDRESS" "KEY_REGISTRAR_ADDRESS"
validate_eth_address "$RELEASE_MANAGER_ADDRESS" "RELEASE_MANAGER_ADDRESS"
if [ "$ENVIRONMENT" != "devnet" ]; then
    validate_eth_address "$TEE_AVS_FACTORY" "TEE_AVS_FACTORY"
fi

log "Starting L1 contract deployment using context for environment: $ENVIRONMENT"

# Change to contracts directory
cd $contractsBasePath

# Ensure output directory exists
mkdir -p script/$ENVIRONMENT/output

# Deploy contracts only if on devnet environment
if [ "$ENVIRONMENT" == "devnet" ]; then
    # Deploy the AVS factory and operator contracts
    log "Deploying main contracts..."

    # Set required variables for deploy target
    VERSION="1.0.0"
    ALLOCATION_DELAY="1"
    METADATA_URI="https://example.com/metadata"
    PROXY_ADMIN="0x0000000000000000000000000000000000000000"
    DELEGATION_APPROVER="0x0000000000000000000000000000000000000000"

    PRIVATE_KEY="${PRIVATE_KEY_DEPLOYER}" \
    RPC_URL="${L1_RPC_URL}" \
    ENVIRONMENT="${ENVIRONMENT}" \
    VERSION="${VERSION}" \
    DELEGATION_MANAGER="${DELEGATION_MANAGER_ADDRESS}" \
    ALLOCATION_MANAGER="${ALLOCATION_MANAGER_ADDRESS}" \
    PERMISSION_CONTROLLER="${PERMISSION_CONTROLLER_ADDRESS}" \
    KEY_REGISTRAR="${KEY_REGISTRAR_ADDRESS}" \
    RELEASE_MANAGER="${RELEASE_MANAGER_ADDRESS}" \
    PROXY_ADMIN="${PROXY_ADMIN}" \
    INITIAL_OWNER="${ADDRESS_DEPLOYER}" \
    DELEGATION_APPROVER="${DELEGATION_APPROVER}" \
    ALLOCATION_DELAY="${ALLOCATION_DELAY}" \
    METADATA_URI="${METADATA_URI}" \
    make deploy-from-env VERIFY=false >&2

    log "Main contract deployment completed successfully."
    
    # Extract TEE_AVS_FACTORY address from deployment output
    DEPLOY_OUTPUT_FILE="${contractsBasePath}/script/output/${ENVIRONMENT}/deploy_l1_output.json"
    if [ -f "$DEPLOY_OUTPUT_FILE" ]; then
        TEE_AVS_FACTORY=$(jq -r '.addresses.teeAVSFactory' "$DEPLOY_OUTPUT_FILE")
        if [ "$TEE_AVS_FACTORY" == "null" ] || [ -z "$TEE_AVS_FACTORY" ]; then
            log "Error: Failed to extract TEE_AVS_FACTORY address from deployment output"
            exit 1
        fi
        log "TEE_AVS_FACTORY deployed at: $TEE_AVS_FACTORY"
    else
        log "Error: Deployment output file not found at $DEPLOY_OUTPUT_FILE"
        exit 1
    fi
fi

# Check if avs_admin_private_key is empty and set it to deployer key if needed
PRIVATE_KEY_AVS_ADMIN=$(echo "$CONTEXT" | jq -r '.context.avs.avs_admin_private_key // ""')
if [ -z "$PRIVATE_KEY_AVS_ADMIN" ] || [ "$PRIVATE_KEY_AVS_ADMIN" = "null" ]; then
    PRIVATE_KEY_AVS_ADMIN="$PRIVATE_KEY_DEPLOYER"
fi

# Deploy AVS using create-avs make target
log "Creating AVS..."
PRIVATE_KEY_DEPLOYER="${PRIVATE_KEY_DEPLOYER}" \
    PRIVATE_KEY_AVS_ADMIN="${PRIVATE_KEY_AVS_ADMIN}" \
    RPC_URL="${L1_RPC_URL}" \
    ENVIRONMENT="${ENVIRONMENT}" \
    METADATA_URI="https://example.com/metadata" \
    PERMISSION_CONTROLLER="${PERMISSION_CONTROLLER_ADDRESS}" \
    TEE_AVS_FACTORY="${TEE_AVS_FACTORY}" \
    make create-avs >&2

log "AVS creation completed successfully."

# Check if there are any additional L1 contracts to deploy
L1_CONTRACTS_DIR="contracts/src/l1-contracts"
HAS_ADDITIONAL_L1_CONTRACTS=false

if [ -d "$L1_CONTRACTS_DIR" ] && [ "$(find "$L1_CONTRACTS_DIR" -name "*.sol" | wc -l)" -gt 0 ]; then
    HAS_ADDITIONAL_L1_CONTRACTS=true
fi

# Deploy additional custom L1 contracts if they exist
if [ "$HAS_ADDITIONAL_L1_CONTRACTS" == "true" ]; then
    log "Deploying additional custom L1 contracts..."
    
    # Deploy additional L1 contracts using forge script
    forge script script/DeployMyL1Contracts.s.sol \
        --rpc-url "${L1_RPC_URL}" \
        --private-key "${PRIVATE_KEY_DEPLOYER}" \
        --broadcast \
        --sig "run(string,string)" \
        "${ENVIRONMENT}" \
        "${CONTEXT}" >&2
    
    log "Additional L1 contract deployment completed successfully."
else
    log "No additional L1 contracts found, skipping custom deployment."
fi

# Process deployment output files
OUTPUT_DIR="script/output/${ENVIRONMENT}"
deployed_contracts='[]'

# Define output file paths
AVS_OUTPUT_FILE="${OUTPUT_DIR}/deploy_avs_l1_output.json"
CUSTOM_CONTRACTS_L1_FILE="${OUTPUT_DIR}/deploy_custom_contracts_l1_output.json"

# Initialize AVS addresses
avs_address=""
registrar_address=""

# Process the AVS output file if it exists
if [ -f "$AVS_OUTPUT_FILE" ]; then
    process_output_file "$AVS_OUTPUT_FILE" "AVS Creation"
    
    # Extract AVS registrar address from the AVS output file
    registrar_address=$(jq -r '.addresses.teeAVSRegistrar // empty' "$AVS_OUTPUT_FILE")
    # The AVS address is the same as the registrar address in this implementation
    avs_address="$registrar_address"
fi

# Process the custom contracts L1 output file if it exists
if [ "$HAS_ADDITIONAL_L1_CONTRACTS" == "true" ] && [ -f "$CUSTOM_CONTRACTS_L1_FILE" ]; then
    process_output_file "$CUSTOM_CONTRACTS_L1_FILE" "Custom L1 Contracts"
fi

# Create the final JSON structure with both avs object and deployed_l1_contracts array
if [ -n "$avs_address" ] && [ -n "$registrar_address" ]; then
    RESULT=$(jq -n \
        --arg avs_addr "$avs_address" \
        --arg reg_addr "$registrar_address" \
        --arg admin_key "$PRIVATE_KEY_AVS_ADMIN" \
        --argjson contracts "$deployed_contracts" \
        '{
            avs: {
                address: $avs_addr,
                registrar_address: $reg_addr,
                avs_admin_private_key: $admin_key
            },
            deployed_l1_contracts: $contracts
        }')
else
    # Fallback if AVS addresses are not found
    RESULT=$(jq -n --argjson contracts "$deployed_contracts" '{ deployed_l1_contracts: $contracts }')
fi

# Print the combined JSON result - this is the ONLY stdout output
echo "$RESULT" | jq -c . 
