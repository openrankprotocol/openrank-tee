#!/usr/bin/env bash
set -e

# Set sudo for non-root user
if [ "$EUID" -eq 0 ]; then
    SUDO=""
else
    SUDO="sudo"
fi

# Function to log info messages
log_info() {
    printf '\033[0;34m[INFO]\033[0m %s\n' "$*" >&2
}

# Function to log success messages
log_success() {
    printf '\033[0;32m[SUCCESS]\033[0m %s\n' "$*" >&2
}

# Function to log warning messages
log_warning() {
    printf '\033[0;33m[WARNING]\033[0m %s\n' "$*" >&2
}

# Function to log error messages
log_error() {
    printf '\033[0;31m[ERROR]\033[0m %s\n' "$*" >&2
}

# Check if we're running on macOS
if [[ "$(uname)" == "Darwin" ]]; then
    PLATFORM="macos"
elif [[ "$(uname)" == "Linux" ]]; then
    PLATFORM="linux"
    # Check if we're on Ubuntu/Debian
    if command -v apt-get >/dev/null 2>&1; then
        LINUX_FLAVOR="debian"
    else
        log_warning "Unsupported Linux distribution. You may need to install dependencies manually."
        LINUX_FLAVOR="unknown"
    fi
else
    log_error "Unsupported platform: $(uname). Only macOS and Debian based linux are supported."
    exit 1
fi

log_info "Detected platform: $PLATFORM $([ "$PLATFORM" == "linux" ] && echo "($LINUX_FLAVOR)")"

# Check if given dir is in path
inpath() {
    echo $PATH | tr ':' '\n' | grep -qx "$1" && echo "$1 is in PATH" || echo "$1 is NOT in PATH"
}

# Add the given dir to the user path and profile
add_to_path() {
  local dir="$1"
  local line="export PATH=\"\$PATH:$dir\""
  local shell_name rc_files file status

  # detect current shell
  if [[ -n "$ZSH_NAME" ]]; then
    shell_name="zsh"
  elif [[ -n "$BASH_VERSION" ]]; then
    shell_name="bash"
  else
    shell_name="${SHELL##*/}"
  fi

  # choose rc files based on shell
  if [[ "$shell_name" == "zsh" ]]; then
    rc_files=(~/.zshrc ~/.zprofile)
  else
    rc_files=(~/.bashrc ~/.bash_profile)
  fi

  # check if "$dir" is already in PATH
  status="$(inpath "$dir")"
  if [[ "$status" == "$dir is in PATH" ]]; then
    return
  fi

  # append export line to each existing rc file and reload it
  for file in "${rc_files[@]}"; do
    [[ -f "$file" ]] || continue
    echo "$line" >>"$file"
    # shellcheck source=/dev/null
    source "$file"
  done
}

# Check and install Homebrew on macOS
install_homebrew() {
    if ! command -v brew >/dev/null 2>&1; then
        log_info "Installing Homebrew..."
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
        # Add Homebrew to PATH for the current session
        if [[ -d "$HOMEBREW_PREFIX/bin" ]]; then
            export PATH="$HOMEBREW_PREFIX/bin:$PATH" # Apple Silicon
        elif [[ -d "/usr/local/bin" ]]; then
            export PATH="/usr/local/bin:$PATH" # Intel
        fi
        log_success "Homebrew installed successfully"
    else
        log_info "Homebrew is already installed"
    fi
}

# Install a package with Homebrew
install_with_brew() {
    local package=$1
    local command=${2:-$1}

    if ! command -v "$command" >/dev/null 2>&1; then
        log_info "Installing $package..."
        brew install "$package"
        log_success "$package installed successfully"
    else
        log_info "$package is already installed"
    fi
}

# Install a package with apt-get
install_with_apt() {
    local package=$1
    local command=${2:-$1}

    if ! command -v "$command" >/dev/null 2>&1; then
        log_info "Installing $package..."
        # update only once per session
        if [ -z "$APT_UPDATED" ]; then
            DEBIAN_FRONTEND=noninteractive APT_LISTCHANGES_FRONTEND=none \
                $SUDO apt-get update -qq
            APT_UPDATED=1
        fi
        # install package quietly and non-interactively
        DEBIAN_FRONTEND=noninteractive APT_LISTCHANGES_FRONTEND=none \
            $SUDO apt-get install -y -qq "$package"
        log_success "$package installed successfully"
    else
        log_info "$package already present"
    fi
}

# Install Foundry (forge, cast, anvil)
install_foundry() {
    if ! command -v forge >/dev/null 2>&1; then
        log_info "Installing Foundry..."
        curl -L https://foundry.paradigm.xyz | bash
        export PATH="$PATH:$HOME/.foundry/bin"
        foundryup

        add_to_path "$HOME/.foundry/bin"

        log_success "Foundry installed successfully"
    else
        log_info "Foundry is already installed"
    fi
}

# Install Docker for osx
install_docker_macos() {
    if ! command -v docker >/dev/null; then
        log_info "Installing Docker Desktop via Homebrew..."
        brew install --cask docker
        open /Applications/Docker.app
    else
        log_info "Docker Desktop already installed"
    fi
}

# Install Docker
install_docker() {
    if command -v docker >/dev/null; then
        log_info "Docker already installed"
        return
    fi

    if [[ "$LINUX_FLAVOR" == "debian" ]]; then
        # avoid interactive prompts (tzdata, etc)
        export DEBIAN_FRONTEND=noninteractive
        export TZ=Etc/UTC

        log_info "Installing Docker on Debian/Ubuntu..."
        $SUDO apt-get update
        $SUDO apt-get install -y \
            ca-certificates \
            curl \
            gnupg \
            lsb-release

        # preseed tzdata
        echo "$TZ" >/etc/timezone
        $SUDO apt-get install -y tzdata
        $SUDO dpkg-reconfigure --frontend noninteractive tzdata

        # Add Dockerâ€™s official GPG key
        curl -fsSL https://download.docker.com/linux/$(
            . /etc/os-release
            echo "$ID"
        )/gpg |
            $SUDO gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

        # Set up the stable repo
        echo \
            "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] \
        https://download.docker.com/linux/$(
                . /etc/os-release
                echo "$ID"
            ) \
        $(lsb_release -cs) stable" |
            $SUDO tee /etc/apt/sources.list.d/docker.list >/dev/null
        $SUDO apt-get update
        $SUDO apt-get install -y docker-ce docker-ce-cli containerd.io
    else
        log_warning "Unsupported distro; please install Docker manually"
        return
    fi

    # Only enable+start via systemd if systemd is PID 1
    if [ "$(ps -p 1 -o comm=)" = "systemd" ]; then
        $SUDO systemctl enable --now docker
        log_success "Docker enabled and started via systemd"
    else
        log_warning "Systemd not available - skipping service enable"
        # Optionally start dockerd in background
        if command -v dockerd &>/dev/null; then
            log_info "Launching dockerd manually"
            nohup dockerd >/var/log/dockerd.log 2>&1 &
            disown
            log_success "dockerd running in background"
        fi
    fi

    log_success "docker installed successfully"
}

# Function to install/upgrade yq on Debian/Ubuntu from source
install_yq_binary() {
    TARGET_VERSION="4.35.1"

    if command -v yq &>/dev/null; then
        # Extract version field
        RAW_VERSION=$(yq --version | awk '{print $2}')
        if [[ "$RAW_VERSION" == "(https://github.com/mikefarah/yq/)" ]]; then
            INSTALLED_VERSION=$(yq --version | awk '{print $4}' | sed 's/^v//')
        else
            INSTALLED_VERSION="$RAW_VERSION"
        fi

        # Compare using sort -V: if INSTALLED < TARGET, upgrade; else skip
        if [[ "$(printf '%s\n%s' "$INSTALLED_VERSION" "$TARGET_VERSION" | sort -V | head -n1)" == "$TARGET_VERSION" ]]; then
            log_info "yq v${INSTALLED_VERSION} meets requirement (>= v${TARGET_VERSION}); skipping install"
            return
        else
            log_info "yq v${INSTALLED_VERSION} is older than v${TARGET_VERSION}; upgrading..."
        fi
    else
        log_info "yq not found; installing v${TARGET_VERSION}..."
    fi

    # Detect current environment
    ARCH=$(uname -m)
    [[ $ARCH == x86_64 ]] && ARCH_SUFFIX=amd64 || ARCH_SUFFIX=arm64

    # Install from github
    curl -Lo /usr/local/bin/yq "https://github.com/mikefarah/yq/releases/download/v${TARGET_VERSION}/yq_linux_${ARCH_SUFFIX}"

    # Ensure executable
    $SUDO chmod +x /usr/local/bin/yq

    # Add to bashrc/profile
    add_to_path "/usr/local/bin"

    log_success "yq installed successfully"
}

# Function to install age binary
install_age_binary() {
    if command -v age &>/dev/null; then
        log_info "age is already installed"
        return
    fi

    log_info "Installing age encryption tool..."

    # Detect architecture
    ARCH=$(uname -m)
    case $ARCH in
        x86_64)
            ARCH_SUFFIX="amd64"
            ;;
        aarch64|arm64)
            ARCH_SUFFIX="arm64"
            ;;
        *)
            log_error "Unsupported architecture: $ARCH"
            return 1
            ;;
    esac

    # Detect OS
    OS=$(uname -s | tr '[:upper:]' '[:lower:]')
    case $OS in
        linux)
            BINARY_OS="linux"
            ;;
        darwin)
            BINARY_OS="darwin"
            ;;
        *)
            log_error "Unsupported OS: $OS"
            return 1
            ;;
    esac

    # Download and install from pre-built binaries
    DOWNLOAD_URL="https://dl.filippo.io/age/latest?for=${BINARY_OS}/${ARCH_SUFFIX}"
    TEMP_DIR=$(mktemp -d)
    ARCHIVE_FILE="$TEMP_DIR/age.tar.gz"

    log_info "Downloading age from $DOWNLOAD_URL..."
    curl -L -o "$ARCHIVE_FILE" "$DOWNLOAD_URL"

    # Extract the archive
    tar -xzf "$ARCHIVE_FILE" -C "$TEMP_DIR"

    # Find the age binary and install it
    find "$TEMP_DIR" -name "age" -type f -executable | head -1 | while read -r AGE_BINARY; do
        $SUDO cp "$AGE_BINARY" /usr/local/bin/age
        $SUDO chmod +x /usr/local/bin/age
    done

    # Also install age-keygen if available
    find "$TEMP_DIR" -name "age-keygen" -type f -executable | head -1 | while read -r KEYGEN_BINARY; do
        $SUDO cp "$KEYGEN_BINARY" /usr/local/bin/age-keygen
        $SUDO chmod +x /usr/local/bin/age-keygen
    done

    # Clean up
    rm -rf "$TEMP_DIR"

    # Add to PATH
    add_to_path "/usr/local/bin"

    log_success "age installed successfully"
}

# Function to install oras binary
install_oras_binary() {
    if command -v oras &>/dev/null; then
        log_info "oras is already installed"
        return
    fi

    log_info "Installing oras (OCI Registry As Storage)..."

    # Detect architecture
    ARCH=$(uname -m)
    case $ARCH in
        x86_64)
            ARCH_SUFFIX="amd64"
            ;;
        aarch64|arm64)
            ARCH_SUFFIX="arm64"
            ;;
        *)
            log_error "Unsupported architecture: $ARCH"
            return 1
            ;;
    esac

    # Detect OS
    OS=$(uname -s | tr '[:upper:]' '[:lower:]')
    case $OS in
        linux)
            BINARY_OS="linux"
            ;;
        darwin)
            BINARY_OS="darwin"
            ;;
        *)
            log_error "Unsupported OS: $OS"
            return 1
            ;;
    esac

    # Get latest version from GitHub API
    LATEST_VERSION=$(curl -s https://api.github.com/repos/oras-project/oras/releases/latest | jq -r .tag_name | sed 's/^v//')
    
    # Download and install from pre-built binaries
    DOWNLOAD_URL="https://github.com/oras-project/oras/releases/download/v${LATEST_VERSION}/oras_${LATEST_VERSION}_${BINARY_OS}_${ARCH_SUFFIX}.tar.gz"
    TEMP_DIR=$(mktemp -d)
    ARCHIVE_FILE="$TEMP_DIR/oras.tar.gz"

    log_info "Downloading oras v${LATEST_VERSION} from $DOWNLOAD_URL..."
    curl -L -o "$ARCHIVE_FILE" "$DOWNLOAD_URL"

    # Extract the archive
    tar -xzf "$ARCHIVE_FILE" -C "$TEMP_DIR"

    # Install the binary
    $SUDO cp "$TEMP_DIR/oras" /usr/local/bin/oras
    $SUDO chmod +x /usr/local/bin/oras

    # Clean up
    rm -rf "$TEMP_DIR"

    # Add to PATH
    add_to_path "/usr/local/bin"

    log_success "oras installed successfully"
}

# Install dependencies based on platform
if [[ "$PLATFORM" == "macos" ]]; then
    install_homebrew
    install_with_brew coreutils
    install_with_brew realpath
    install_with_brew make
    install_with_brew curl
    install_with_brew jq
    install_with_brew yq
    install_with_brew age
    install_with_brew oras
    install_foundry
    install_docker_macos
elif [[ "$PLATFORM" == "linux" ]]; then
    if [[ "$LINUX_FLAVOR" == "debian" ]]; then
        install_with_apt apt-utils
        install_with_apt curl
        install_with_apt jq
        install_with_apt make
        install_with_apt iproute2
        install_with_apt coreutils realpath
        install_yq_binary
        install_age_binary
        install_oras_binary
        install_foundry
        install_docker
    else
        log_warning "Unsupported Linux distribution. Please install dependencies manually:"
        log_warning "- curl"
        log_warning "- jq"
        log_warning "- yq"
        log_warning "- make"
        log_warning "- iproute"
        log_warning "- realpath (from coreutils)"
        log_warning "- age"
        log_warning "- forge (from Foundry)"
        log_warning "- docker"
    fi
fi

# Make all scripts executable
log_info "Making all scripts in .devkit/scripts executable..."
chmod +x .devkit/scripts/*
log_success "All scripts are now executable"

log_info "Running dependency checks..."

# Check if all dependencies are installed properly
MISSING_DEPS=()
for cmd in curl jq yq make realpath age oras forge docker; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
        MISSING_DEPS+=("$cmd")
    fi
done

if [ ${#MISSING_DEPS[@]} -eq 0 ]; then
    log_success "All dependencies are installed successfully!"
else
    log_error "Some dependencies could not be installed automatically:"
    for dep in "${MISSING_DEPS[@]}"; do
        log_error "- $dep"
    done
    log_error "Please install these dependencies manually and run this script again."
    exit 1
fi

rm -rf contracts/.git || true

cat .devkit/templateGitignore >>.gitignore
rm .devkit/templateGitignore

# Generate mnemonic if it doesn't exist
MNEMONIC_FILE="mnemonic.txt"
if [ ! -f "$MNEMONIC_FILE" ]; then
    log_info "Generating secure mnemonic..."
    "$( dirname "${BASH_SOURCE[0]}" )/generate-mnemonic"
fi

log_info "Initialization complete. You can now run the other scripts in .devkit/scripts/"
